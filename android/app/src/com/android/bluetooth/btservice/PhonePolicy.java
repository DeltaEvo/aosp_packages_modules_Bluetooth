/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.bluetooth.btservice;

import static com.android.bluetooth.Utils.isDualModeAudioEnabled;

import android.annotation.RequiresPermission;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothProfile;
import android.bluetooth.BluetoothUuid;
import android.content.IntentFilter;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.ParcelUuid;
import android.os.SystemProperties;
import android.util.Log;

import com.android.bluetooth.R;
import com.android.bluetooth.Utils;
import com.android.bluetooth.a2dp.A2dpService;
import com.android.bluetooth.bas.BatteryService;
import com.android.bluetooth.bass_client.BassClientService;
import com.android.bluetooth.btservice.storage.DatabaseManager;
import com.android.bluetooth.csip.CsipSetCoordinatorService;
import com.android.bluetooth.flags.FeatureFlags;
import com.android.bluetooth.hap.HapClientService;
import com.android.bluetooth.hearingaid.HearingAidService;
import com.android.bluetooth.hfp.HeadsetService;
import com.android.bluetooth.hid.HidHostService;
import com.android.bluetooth.le_audio.LeAudioService;
import com.android.bluetooth.pan.PanService;
import com.android.bluetooth.vc.VolumeControlService;
import com.android.internal.annotations.VisibleForTesting;

import java.util.HashSet;
import java.util.List;
import java.util.Objects;

// Describes the phone policy
//
// Policies are usually governed by outside events that may warrant an action. We talk about various
// events and the resulting outcome from this policy:
//
// 1. Adapter turned ON: At this point we will try to auto-connect the (device, profile) pairs which
// have PRIORITY_AUTO_CONNECT. The fact that we *only* auto-connect Headset and A2DP is something
// that is hardcoded and specific to phone policy (see autoConnect() function)
// 2. When the profile connection-state changes: At this point if a new profile gets CONNECTED we
// will try to connect other profiles on the same device. This is to avoid collision if devices
// somehow end up trying to connect at same time or general connection issues.
public class PhonePolicy implements AdapterService.BluetoothStateCallback {
    private static final boolean DBG = true;
    private static final String TAG = "BluetoothPhonePolicy";

    // Message types for the handler (internal messages generated by intents or timeouts)
    private static final int MESSAGE_CONNECT_OTHER_PROFILES = 3;

    @VisibleForTesting static final String AUTO_CONNECT_PROFILES_PROPERTY =
            "bluetooth.auto_connect_profiles.enabled";

    private static final String LE_AUDIO_CONNECTION_BY_DEFAULT_PROPERTY =
            "ro.bluetooth.leaudio.le_audio_connection_by_default";

    @VisibleForTesting
    static final String BYPASS_LE_AUDIO_ALLOWLIST_PROPERTY =
            "persist.bluetooth.leaudio.bypass_allow_list";

    // Timeouts
    @VisibleForTesting static int sConnectOtherProfilesTimeoutMillis = 6000; // 6s

    private DatabaseManager mDatabaseManager;
    private final FeatureFlags mFeatureFlags;
    private final AdapterService mAdapterService;
    private final ServiceFactory mFactory;
    private final Handler mHandler;
    private final HashSet<BluetoothDevice> mHeadsetRetrySet = new HashSet<>();
    private final HashSet<BluetoothDevice> mA2dpRetrySet = new HashSet<>();
    private final HashSet<BluetoothDevice> mConnectOtherProfilesDeviceSet = new HashSet<>();
    @VisibleForTesting boolean mAutoConnectProfilesSupported;
    @VisibleForTesting boolean mLeAudioEnabledByDefault;

    @Override
    public void onBluetoothStateChange(int prevState, int newState) {
        // Only act if the adapter has actually changed state from non-ON to ON.
        // NOTE: ON is the state depicting BREDR ON and not just BLE ON.
        if (newState == BluetoothAdapter.STATE_ON) {
            resetStates();
            autoConnect();
        }
    }

    public void profileConnectionStateChanged(
            int profile, BluetoothDevice device, int fromState, int toState) {
        switch (profile) {
            case BluetoothProfile.A2DP:
            case BluetoothProfile.HEADSET:
            case BluetoothProfile.LE_AUDIO:
            case BluetoothProfile.CSIP_SET_COORDINATOR:
            case BluetoothProfile.VOLUME_CONTROL:
                mHandler.post(
                        () -> processProfileStateChanged(device, profile, toState, fromState));
                break;
            default:
                break;
        }
    }

    /**
     * Called when active state of audio profiles changed
     *
     * @param profile The Bluetooth profile of which active state changed
     * @param device The device currently activated. {@code null} if no A2DP device activated
     */
    public void profileActiveDeviceChanged(int profile, BluetoothDevice device) {
        mHandler.post(() -> processActiveDeviceChanged(device, profile));
    }

    public void handleAclConnected(BluetoothDevice device) {
        mHandler.post(() -> processDeviceConnected(device));
    }

    // Handler to handoff intents to class thread
    class PhonePolicyHandler extends Handler {
        PhonePolicyHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MESSAGE_CONNECT_OTHER_PROFILES: {
                    // Called when we try connect some profiles in processConnectOtherProfiles but
                    // we send a delayed message to try connecting the remaining profiles
                    BluetoothDevice device = (BluetoothDevice) msg.obj;
                    processConnectOtherProfiles(device);
                    mConnectOtherProfilesDeviceSet.remove(device);
                    break;
                }
            }
        }
    }

    ;

    // Policy API functions for lifecycle management (protected)
    protected void start() {
        mAdapterService.registerBluetoothStateCallback((command) -> mHandler.post(command), this);

        IntentFilter filter = new IntentFilter();
        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
    }

    protected void cleanup() {
        mAdapterService.unregisterBluetoothStateCallback(this);
        resetStates();
    }

    PhonePolicy(AdapterService service, ServiceFactory factory, FeatureFlags featureFlags) {
        mAdapterService = service;
        mDatabaseManager = Objects.requireNonNull(mAdapterService.getDatabase(),
                "DatabaseManager cannot be null when PhonePolicy starts");
        mFeatureFlags = Objects.requireNonNull(featureFlags, "Feature Flags cannot be null");
        mFactory = factory;
        mHandler = new PhonePolicyHandler(service.getMainLooper());
        mAutoConnectProfilesSupported =
                SystemProperties.getBoolean(AUTO_CONNECT_PROFILES_PROPERTY, false);
        mLeAudioEnabledByDefault =
                SystemProperties.getBoolean(LE_AUDIO_CONNECTION_BY_DEFAULT_PROPERTY, true);
    }

    // Policy implementation, all functions MUST be private
    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)
    private void processInitProfilePriorities(BluetoothDevice device, ParcelUuid[] uuids) {
        debugLog("processInitProfilePriorities() - device " + device);
        HidHostService hidService = mFactory.getHidHostService();
        A2dpService a2dpService = mFactory.getA2dpService();
        HeadsetService headsetService = mFactory.getHeadsetService();
        PanService panService = mFactory.getPanService();
        HearingAidService hearingAidService = mFactory.getHearingAidService();
        LeAudioService leAudioService = mFactory.getLeAudioService();
        CsipSetCoordinatorService csipSetCoordinatorService =
             mFactory.getCsipSetCoordinatorService();
        VolumeControlService volumeControlService =
             mFactory.getVolumeControlService();
        HapClientService hapClientService = mFactory.getHapClientService();
        BassClientService bcService = mFactory.getBassClientService();
        BatteryService batteryService = mFactory.getBatteryService();

        final boolean isBypassLeAudioAllowlist =
                SystemProperties.getBoolean(BYPASS_LE_AUDIO_ALLOWLIST_PROPERTY, false);

        boolean isLeAudioProfileAllowed =
                (leAudioService != null)
                        && Utils.arrayContains(uuids, BluetoothUuid.LE_AUDIO)
                        && (leAudioService.getConnectionPolicy(device)
                                != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN)
                        && (mLeAudioEnabledByDefault || isDualModeAudioEnabled())
                        && (isBypassLeAudioAllowlist || mAdapterService.isLeAudioAllowed(device));

        debugLog(
                "mLeAudioEnabledByDefault: "
                        + mLeAudioEnabledByDefault
                        + ", isBypassLeAudioAllowlist: "
                        + isBypassLeAudioAllowlist
                        + ", isLeAudioAllowDevice: "
                        + mAdapterService.isLeAudioAllowed(device));

        // Set profile priorities only for the profiles discovered on the remote device.
        // This avoids needless auto-connect attempts to profiles non-existent on the remote device
        if ((hidService != null)
                && (Utils.arrayContains(uuids, BluetoothUuid.HID)
                        || Utils.arrayContains(uuids, BluetoothUuid.HOGP))
                && (hidService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (mAutoConnectProfilesSupported) {
                hidService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            } else {
                mAdapterService.getDatabase().setProfileConnectionPolicy(device,
                        BluetoothProfile.HID_HOST, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            }
        }

        if ((headsetService != null)
                && ((Utils.arrayContains(uuids, BluetoothUuid.HSP)
                                || Utils.arrayContains(uuids, BluetoothUuid.HFP))
                        && (headsetService.getConnectionPolicy(device)
                                == BluetoothProfile.CONNECTION_POLICY_UNKNOWN))) {
            if (!isDualModeAudioEnabled() && isLeAudioProfileAllowed) {
                debugLog("clear hfp profile priority for the le audio dual mode device "
                        + device);
                mAdapterService.getDatabase().setProfileConnectionPolicy(device,
                        BluetoothProfile.HEADSET, BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            } else {
                if (mAutoConnectProfilesSupported) {
                    headsetService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService.getDatabase().setProfileConnectionPolicy(device,
                            BluetoothProfile.HEADSET, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            }
        }

        if ((a2dpService != null)
                && (Utils.arrayContains(uuids, BluetoothUuid.A2DP_SINK)
                        || Utils.arrayContains(uuids, BluetoothUuid.ADV_AUDIO_DIST))
                && (a2dpService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (!isDualModeAudioEnabled() && isLeAudioProfileAllowed) {
                debugLog("clear a2dp profile priority for the le audio dual mode device " + device);
                mAdapterService.getDatabase().setProfileConnectionPolicy(device,
                        BluetoothProfile.A2DP, BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            } else {
                if (mAutoConnectProfilesSupported) {
                    a2dpService.setConnectionPolicy(device,
                            BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService
                            .getDatabase()
                            .setProfileConnectionPolicy(
                                    device,
                                    BluetoothProfile.A2DP,
                                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            }
        }

        // CSIP should be connected prior to LE Audio
        if ((csipSetCoordinatorService != null)
                && (Utils.arrayContains(uuids, BluetoothUuid.COORDINATED_SET))
                && (csipSetCoordinatorService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            // Always allow CSIP during pairing process regardless of LE audio preference
            if (mAutoConnectProfilesSupported) {
                csipSetCoordinatorService.setConnectionPolicy(
                        device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            } else {
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.CSIP_SET_COORDINATOR,
                                BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            }
        }

        /* Make sure to connect Volume Control before LeAudio service */
        if ((volumeControlService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.VOLUME_CONTROL)
                && (volumeControlService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (isLeAudioProfileAllowed) {
                debugLog("setting volume control profile priority for device " + device);
                if (mAutoConnectProfilesSupported) {
                    volumeControlService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService
                            .getDatabase()
                            .setProfileConnectionPolicy(
                                    device,
                                    BluetoothProfile.VOLUME_CONTROL,
                                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            } else {
                debugLog("clear VCP priority because dual mode is disabled by default");
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.VOLUME_CONTROL,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            }
        }

        // If we do not have a stored priority for HFP/A2DP (all roles) then default to on.
        if ((panService != null)
                && (Utils.arrayContains(uuids, BluetoothUuid.PANU)
                        && (panService.getConnectionPolicy(device)
                                == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)
                        && mAdapterService
                                .getResources()
                                .getBoolean(R.bool.config_bluetooth_pan_enable_autoconnect))) {
            if (mAutoConnectProfilesSupported) {
                panService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            } else {
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.PAN,
                                BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            }
        }

        if ((leAudioService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.LE_AUDIO)
                && (leAudioService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (isLeAudioProfileAllowed) {
                debugLog("setting le audio profile priority for device " + device);
                if (mAutoConnectProfilesSupported) {
                    leAudioService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService
                            .getDatabase()
                            .setProfileConnectionPolicy(
                                    device,
                                    BluetoothProfile.LE_AUDIO,
                                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            } else {
                debugLog("clear LEA profile priority because LE audio is not allowed");
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.LE_AUDIO,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            }
        }

        if ((hearingAidService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.HEARING_AID)
                && (hearingAidService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (isLeAudioProfileAllowed) {
                debugLog("LE Audio preferred over ASHA for device " + device);
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.HEARING_AID,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            } else {
                debugLog("setting hearing aid profile priority for device " + device);
                if (mAutoConnectProfilesSupported) {
                    hearingAidService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService
                            .getDatabase()
                            .setProfileConnectionPolicy(
                                    device,
                                    BluetoothProfile.HEARING_AID,
                                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            }
        }

        if ((hapClientService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.HAS)
                && (hapClientService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            debugLog("setting hearing access profile priority for device " + device);
            if (isLeAudioProfileAllowed) {
                if (mAutoConnectProfilesSupported) {
                    hapClientService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService.getDatabase().setProfileConnectionPolicy(device,
                            BluetoothProfile.HAP_CLIENT,
                            BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            } else {
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.HAP_CLIENT,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            }
        }

        if ((bcService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.BASS)
                && (bcService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            if (isLeAudioProfileAllowed) {
                debugLog("setting broadcast assistant profile priority for device " + device);
                if (mAutoConnectProfilesSupported) {
                    bcService.setConnectionPolicy(
                            device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                } else {
                    mAdapterService
                            .getDatabase()
                            .setProfileConnectionPolicy(
                                    device,
                                    BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,
                                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);
                }
            } else {
                debugLog(
                        "clear broadcast assistant profile priority if le audio profile is not"
                                + " allowed");
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
            }
        }

        if ((batteryService != null)
                && Utils.arrayContains(uuids, BluetoothUuid.BATTERY)
                && (batteryService.getConnectionPolicy(device)
                        == BluetoothProfile.CONNECTION_POLICY_UNKNOWN)) {
            debugLog("setting battery profile priority for device " + device);
            if (mAutoConnectProfilesSupported) {
                batteryService.setConnectionPolicy(device,
                        BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            } else {
                mAdapterService
                        .getDatabase()
                        .setProfileConnectionPolicy(
                                device,
                                BluetoothProfile.BATTERY,
                                BluetoothProfile.CONNECTION_POLICY_ALLOWED);
            }
        }
    }

    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)
    private void processProfileStateChanged(BluetoothDevice device, int profileId, int nextState,
            int prevState) {
        debugLog("processProfileStateChanged, device=" + device + ", profile="
                + BluetoothProfile.getProfileName(profileId) + ", " + prevState + " -> "
                + nextState);
        if (((profileId == BluetoothProfile.A2DP)
                || (profileId == BluetoothProfile.HEADSET)
                || (profileId == BluetoothProfile.LE_AUDIO)
                || (profileId == BluetoothProfile.CSIP_SET_COORDINATOR)
                || (profileId == BluetoothProfile.VOLUME_CONTROL)
                || (profileId == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT))) {
            if (nextState == BluetoothProfile.STATE_CONNECTED) {
                switch (profileId) {
                    case BluetoothProfile.A2DP:
                        mA2dpRetrySet.remove(device);
                        break;
                    case BluetoothProfile.HEADSET:
                        mHeadsetRetrySet.remove(device);
                        break;
                }
                connectOtherProfile(device);
            }
            if (nextState == BluetoothProfile.STATE_DISCONNECTED) {
                if (prevState == BluetoothProfile.STATE_CONNECTING
                        || prevState == BluetoothProfile.STATE_DISCONNECTING) {
                    mDatabaseManager.setDisconnection(device, profileId);
                }
                handleAllProfilesDisconnected(device);
            }
        }
    }

    /**
     * Updates the last connection date in the connection order database for the newly active device
     * if connected to the A2DP profile. If this is a dual mode audio device (supports classic and
     * LE Audio), LE Audio is made active, and {@link Utils#isDualModeAudioEnabled()} is false, A2DP
     * and HFP will be disconnected.
     *
     * @param device is the device we just made the active device
     */
    private void processActiveDeviceChanged(BluetoothDevice device, int profileId) {
        debugLog("processActiveDeviceChanged, device=" + device + ", profile="
                + BluetoothProfile.getProfileName(profileId) + " isDualModeAudioEnabled="
                + isDualModeAudioEnabled());

        if (device != null) {
            mDatabaseManager.setConnection(device, profileId);

            if (isDualModeAudioEnabled()) return;
            if (profileId == BluetoothProfile.LE_AUDIO) {
                A2dpService a2dpService = mFactory.getA2dpService();
                HeadsetService hsService = mFactory.getHeadsetService();
                LeAudioService leAudioService = mFactory.getLeAudioService();
                if (leAudioService == null) {
                    debugLog("processActiveDeviceChanged: LeAudioService is null");
                    return;
                }
                List<BluetoothDevice> leAudioActiveGroupDevices =
                        leAudioService.getGroupDevices(leAudioService.getGroupId(device));

                // Disable classic audio profiles for all group devices as lead can change
                for (BluetoothDevice activeGroupDevice: leAudioActiveGroupDevices) {
                    if (hsService != null) {
                        debugLog("Disable HFP for the LE audio dual mode group device "
                                + activeGroupDevice);
                        hsService.setConnectionPolicy(activeGroupDevice,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
                    }
                    if (a2dpService != null) {
                        debugLog("Disable A2DP for the LE audio dual mode group device "
                                + activeGroupDevice);
                        a2dpService.setConnectionPolicy(activeGroupDevice,
                                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
                    }
                }
            }
        }
    }

    private void processDeviceConnected(BluetoothDevice device) {
        debugLog("processDeviceConnected, device=" + device);
        mDatabaseManager.setConnection(device);
    }

    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)
    private boolean handleAllProfilesDisconnected(BluetoothDevice device) {
        boolean atLeastOneProfileConnectedForDevice = false;
        boolean allProfilesEmpty = true;
        HeadsetService hsService = mFactory.getHeadsetService();
        A2dpService a2dpService = mFactory.getA2dpService();
        PanService panService = mFactory.getPanService();
        LeAudioService leAudioService = mFactory.getLeAudioService();
        CsipSetCoordinatorService csipSetCooridnatorService =
        mFactory.getCsipSetCoordinatorService();

        if (hsService != null) {
            List<BluetoothDevice> hsConnDevList = hsService.getConnectedDevices();
            allProfilesEmpty &= hsConnDevList.isEmpty();
            atLeastOneProfileConnectedForDevice |= hsConnDevList.contains(device);
        }
        if (a2dpService != null) {
            List<BluetoothDevice> a2dpConnDevList = a2dpService.getConnectedDevices();
            allProfilesEmpty &= a2dpConnDevList.isEmpty();
            atLeastOneProfileConnectedForDevice |= a2dpConnDevList.contains(device);
        }
        if (csipSetCooridnatorService != null) {
            List<BluetoothDevice> csipConnDevList = csipSetCooridnatorService.getConnectedDevices();
            allProfilesEmpty &= csipConnDevList.isEmpty();
            atLeastOneProfileConnectedForDevice |= csipConnDevList.contains(device);
        }
        if (panService != null) {
            List<BluetoothDevice> panConnDevList = panService.getConnectedDevices();
            allProfilesEmpty &= panConnDevList.isEmpty();
            atLeastOneProfileConnectedForDevice |= panConnDevList.contains(device);
        }
        if (leAudioService != null) {
            List<BluetoothDevice> leAudioConnDevList = leAudioService.getConnectedDevices();
            allProfilesEmpty &= leAudioConnDevList.isEmpty();
            atLeastOneProfileConnectedForDevice |= leAudioConnDevList.contains(device);
        }

        if (!atLeastOneProfileConnectedForDevice) {
            // Consider this device as fully disconnected, don't bother connecting others
            debugLog("handleAllProfilesDisconnected: all profiles disconnected for " + device);
            mHeadsetRetrySet.remove(device);
            mA2dpRetrySet.remove(device);
            if (allProfilesEmpty) {
                debugLog("handleAllProfilesDisconnected: all profiles disconnected for all"
                        + " devices");
                // reset retry status so that in the next round we can start retrying connections
                resetStates();
            }
            return true;
        }
        return false;
    }

    private void resetStates() {
        mHeadsetRetrySet.clear();
        mA2dpRetrySet.clear();
    }

    @VisibleForTesting
    @RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
    void autoConnect() {
        if (mAdapterService.getState() != BluetoothAdapter.STATE_ON) {
            Log.e(TAG, "autoConnect: BT is not ON. Exiting autoConnect");
            return;
        }
        if (mAdapterService.isQuietModeEnabled()) {
            Log.i(TAG, "autoConnect() - BT is in quiet mode. Not initiating autoConnect");
            return;
        }

        final BluetoothDevice mostRecentlyActiveA2dpDevice =
                mDatabaseManager.getMostRecentlyConnectedA2dpDevice();
        if (mostRecentlyActiveA2dpDevice != null) {
            debugLog(
                    "autoConnect: Device "
                            + mostRecentlyActiveA2dpDevice
                            + " attempting auto connection");
            autoConnectHeadset(mostRecentlyActiveA2dpDevice);
            autoConnectA2dp(mostRecentlyActiveA2dpDevice);
            autoConnectHidHost(mostRecentlyActiveA2dpDevice);
            return;
        }

        if (!mFeatureFlags.autoConnectOnHfpWhenNoA2dpDevice()) {
            debugLog("HFP auto connect is not enabled");
            return;
        }

        if (mFeatureFlags.autoConnectOnMultipleHfpWhenNoA2dpDevice()) {
            final List<BluetoothDevice> mostRecentlyConnectedHfpDevices =
                    mDatabaseManager.getMostRecentlyActiveHfpDevices();
            for (BluetoothDevice hfpDevice : mostRecentlyConnectedHfpDevices) {
                debugLog("autoConnect: Headset device: " + hfpDevice);
                autoConnectHeadset(hfpDevice);
            }
            if (mostRecentlyConnectedHfpDevices.size() == 0) {
                Log.i(TAG, "autoConnect: No device to reconnect to");
            }
            return;
        }
        debugLog("HFP multi auto connect is not enabled");

        // Try to autoConnect with Hfp only if there was no a2dp valid device
        final BluetoothDevice mostRecentlyConnectedHfpDevice =
                mDatabaseManager.getMostRecentlyActiveHfpDevice();
        if (mostRecentlyConnectedHfpDevice != null) {
            debugLog("autoConnect: Headset device: " + mostRecentlyConnectedHfpDevice);
            autoConnectHeadset(mostRecentlyConnectedHfpDevice);
            return;
        }
        Log.i(TAG, "autoConnect: No device to reconnect to");
    }

    private void autoConnectA2dp(BluetoothDevice device) {
        final A2dpService a2dpService = mFactory.getA2dpService();
        if (a2dpService == null) {
            warnLog("autoConnectA2dp: service is null, failed to connect to " + device);
            return;
        }
        int a2dpConnectionPolicy = a2dpService.getConnectionPolicy(device);
        if (a2dpConnectionPolicy == BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            debugLog("autoConnectA2dp: connecting A2DP with " + device);
            a2dpService.connect(device);
        } else {
            debugLog("autoConnectA2dp: skipped auto-connect A2DP with device " + device
                    + " connectionPolicy " + a2dpConnectionPolicy);
        }
    }

    @RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
    private void autoConnectHeadset(BluetoothDevice device) {
        final HeadsetService hsService = mFactory.getHeadsetService();
        if (hsService == null) {
            warnLog("autoConnectHeadset: service is null, failed to connect to " + device);
            return;
        }
        int headsetConnectionPolicy = hsService.getConnectionPolicy(device);
        if (headsetConnectionPolicy == BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            debugLog("autoConnectHeadset: Connecting HFP with " + device);
            hsService.connect(device);
        } else {
            debugLog("autoConnectHeadset: skipped auto-connect HFP with device " + device
                    + " connectionPolicy " + headsetConnectionPolicy);
        }
    }

    @RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
    private void autoConnectHidHost(BluetoothDevice device) {
        final HidHostService hidHostService = mFactory.getHidHostService();
        if (hidHostService == null) {
            warnLog("autoConnectHidHost: service is null, failed to connect to " + device);
            return;
        }
        int hidHostConnectionPolicy = hidHostService.getConnectionPolicy(device);
        if (hidHostConnectionPolicy == BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            debugLog("autoConnectHidHost: Connecting HID with " + device);
            hidHostService.connect(device);
        } else {
            debugLog("autoConnectHidHost: skipped auto-connect HID with device " + device
                    + " connectionPolicy " + hidHostConnectionPolicy);
        }
    }

    private void connectOtherProfile(BluetoothDevice device) {
        if (mAdapterService.isQuietModeEnabled()) {
            debugLog("connectOtherProfile: in quiet mode, skip connect other profile " + device);
            return;
        }
        if (mConnectOtherProfilesDeviceSet.contains(device)) {
            debugLog("connectOtherProfile: already scheduled callback for " + device);
            return;
        }
        mConnectOtherProfilesDeviceSet.add(device);
        Message m = mHandler.obtainMessage(MESSAGE_CONNECT_OTHER_PROFILES);
        m.obj = device;
        mHandler.sendMessageDelayed(m, sConnectOtherProfilesTimeoutMillis);
    }

    // This function is called whenever a profile is connected.  This allows any other bluetooth
    // profiles which are not already connected or in the process of connecting to attempt to
    // connect to the device that initiated the connection.  In the event that this function is
    // invoked and there are no current bluetooth connections no new profiles will be connected.
    @RequiresPermission(allOf = {
            android.Manifest.permission.BLUETOOTH_PRIVILEGED,
            android.Manifest.permission.MODIFY_PHONE_STATE,
    })
    private void processConnectOtherProfiles(BluetoothDevice device) {
        debugLog("processConnectOtherProfiles, device=" + device);
        if (mAdapterService.getState() != BluetoothAdapter.STATE_ON) {
            warnLog("processConnectOtherProfiles, adapter is not ON " + mAdapterService.getState());
            return;
        }

        /* Make sure that device is still connected before connecting other profiles */
        if (mAdapterService.getConnectionState(device)
                == BluetoothDevice.CONNECTION_STATE_DISCONNECTED) {
            debugLog("processConnectOtherProfiles: device is not connected anymore " + device);
            return;
        }

        if (handleAllProfilesDisconnected(device)) {
            debugLog("processConnectOtherProfiles: all profiles disconnected for " + device);
            return;
        }

        HeadsetService hsService = mFactory.getHeadsetService();
        A2dpService a2dpService = mFactory.getA2dpService();
        PanService panService = mFactory.getPanService();
        LeAudioService leAudioService = mFactory.getLeAudioService();
        CsipSetCoordinatorService csipSetCooridnatorService =
            mFactory.getCsipSetCoordinatorService();
        VolumeControlService volumeControlService =
            mFactory.getVolumeControlService();
        BatteryService batteryService = mFactory.getBatteryService();
        HidHostService hidHostService = mFactory.getHidHostService();
        BassClientService bcService = mFactory.getBassClientService();

        if (hsService != null) {
            if (!mHeadsetRetrySet.contains(device) && (hsService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (hsService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to Headset with device " + device);
                mHeadsetRetrySet.add(device);
                hsService.connect(device);
            }
        }
        if (a2dpService != null) {
            if (!mA2dpRetrySet.contains(device) && (a2dpService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (a2dpService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to A2DP with device " + device);
                mA2dpRetrySet.add(device);
                a2dpService.connect(device);
            }
        }
        if (panService != null) {
            List<BluetoothDevice> panConnDevList = panService.getConnectedDevices();
            // TODO: the panConnDevList.isEmpty() check below should be removed once
            // Multi-PAN is supported.
            if (panConnDevList.isEmpty() && (panService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (panService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to PAN with device " + device);
                panService.connect(device);
            }
        }
        if (leAudioService != null) {
            List<BluetoothDevice> leAudioConnDevList = leAudioService.getConnectedDevices();
            if (!leAudioConnDevList.contains(device)
                    && (leAudioService.getConnectionPolicy(device)
                            == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (leAudioService.getConnectionState(device)
                            == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to LEAudio with device " + device);
                leAudioService.connect(device);
            }
        }
        if (csipSetCooridnatorService != null) {
            List<BluetoothDevice> csipConnDevList = csipSetCooridnatorService.getConnectedDevices();
            if (!csipConnDevList.contains(device) && (csipSetCooridnatorService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (csipSetCooridnatorService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to CSIP with device " + device);
                csipSetCooridnatorService.connect(device);
            }
        }
        if (volumeControlService != null) {
            List<BluetoothDevice> vcConnDevList = volumeControlService.getConnectedDevices();
            if (!vcConnDevList.contains(device) && (volumeControlService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (volumeControlService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to VCP with device " + device);
                volumeControlService.connect(device);
            }
        }
        if (batteryService != null) {
            List<BluetoothDevice> connectedDevices = batteryService.getConnectedDevices();
            if (!connectedDevices.contains(device) && (batteryService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (batteryService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to BAS with device " + device);
                batteryService.connect(device);
            }
        }
        if (hidHostService != null) {
            if ((hidHostService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (hidHostService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to HID with device " + device);
                hidHostService.connect(device);
            }
        }
        if (bcService != null) {
            List<BluetoothDevice> connectedDevices = bcService.getConnectedDevices();
            if (!connectedDevices.contains(device) && (bcService.getConnectionPolicy(device)
                    == BluetoothProfile.CONNECTION_POLICY_ALLOWED)
                    && (bcService.getConnectionState(device)
                    == BluetoothProfile.STATE_DISCONNECTED)) {
                debugLog("Retrying connection to BASS with device " + device);
                bcService.connect(device);
            }
        }
    }

    /**
     * Direct call prior to sending out {@link BluetoothDevice#ACTION_UUID}. This indicates that
     * service discovery is complete and passes the UUIDs directly to PhonePolicy.
     *
     * @param device is the remote device whose services have been discovered
     * @param uuids are the services supported by the remote device
     */
    void onUuidsDiscovered(BluetoothDevice device, ParcelUuid[] uuids) {
        debugLog("onUuidsDiscovered: discovered services for device " + device);
        if (uuids != null) {
            processInitProfilePriorities(device, uuids);
        } else {
            warnLog("onUuidsDiscovered: uuids is null for device " + device);
        }
    }

    private static void debugLog(String msg) {
        if (DBG) {
            Log.i(TAG, msg);
        }
    }

    private static void warnLog(String msg) {
        Log.w(TAG, msg);
    }
}
