# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Security grpc interface."""

import asyncio
import logging
from typing import AsyncGenerator
from typing import AsyncIterator

from floss.pandora.floss import adapter_client
from floss.pandora.floss import floss_enums
from floss.pandora.floss import utils
from floss.pandora.server import bluetooth as bluetooth_module
from google.protobuf import empty_pb2
from google.protobuf import wrappers_pb2
import grpc
from pandora import security_grpc_aio
from pandora import security_pb2


class SecurityService(security_grpc_aio.SecurityServicer):
    """Service to trigger Bluetooth Host security pairing procedures.

    This class implements the Pandora bluetooth test interfaces,
    where the meta class definition is automatically generated by the protobuf.
    The interface definition can be found in:
    https://cs.android.com/android/platform/superproject/+/main:external
    /pandora/bt-test-interfaces/pandora/security.proto
    """

    def __init__(self, server: grpc.aio.Server, bluetooth: bluetooth_module.Bluetooth):
        self.server = server
        self.bluetooth = bluetooth
        self.manually_confirm = False
        self.on_pairing_count = 0

    async def OnPairing(self, request: AsyncIterator[security_pb2.PairingEventAnswer],
                        context: grpc.ServicerContext) -> AsyncGenerator[security_pb2.PairingEvent, None]:
        logging.info('OnPairing')
        on_pairing_id = self.on_pairing_count
        self.on_pairing_count = self.on_pairing_count + 1

        class PairingObserver(adapter_client.BluetoothCallbacks):
            """Observer to observe all pairing events."""

            def __init__(self, loop: asyncio.AbstractEventLoop, task):
                self.loop = loop
                self.task = task

            @utils.glib_callback()
            def on_ssp_request(self, remote_device, class_of_device, variant, passkey):
                address, name = remote_device

                result = (address, name, variant, passkey)
                asyncio.run_coroutine_threadsafe(self.task['pairing_events'].put(result), self.loop)

            @utils.glib_callback()
            def on_pin_request(self, remote_device, cod, min_16_digit):
                address, name = remote_device

                if min_16_digit:
                    variant = floss_enums.PairingVariant.PIN_16_DIGITS_ENTRY
                else:
                    variant = floss_enums.PairingVariant.PIN_ENTRY
                result = (address, name, variant, min_16_digit)
                asyncio.run_coroutine_threadsafe(self.task['pairing_events'].put(result), self.loop)

            @utils.glib_callback()
            def on_pin_display(self, remote_device, pincode):
                address, name = remote_device

                variant = floss_enums.PairingVariant.PIN_NOTIFICATION
                result = (address, name, variant, pincode)
                asyncio.run_coroutine_threadsafe(self.task['pairing_events'].put(result), self.loop)

        pairing_answers = request

        async def streaming_answers(self):
            while True:
                nonlocal pairing_answers
                nonlocal on_pairing_id

                logging.info('OnPairing[%s]: Wait for pairing answer...', on_pairing_id)
                pairing_answer = await utils.anext(pairing_answers)

                answer = pairing_answer.WhichOneof('answer')
                address = utils.address_from(pairing_answer.event.address)
                logging.info('OnPairing[%s]: Pairing answer: %s address: %s', on_pairing_id, answer, address)

                if answer == 'confirm':
                    self.bluetooth.set_pairing_confirmation(address, True)
                elif answer == 'passkey':
                    self.bluetooth.set_pin(address, True, list(str(answer.passkey).zfill(6).encode()))
                elif answer == 'pin':
                    self.bluetooth.set_pin(address, True, list(answer.pin))

        observers = []
        try:
            self.manually_confirm = True

            pairing_events = asyncio.Queue()
            observer = PairingObserver(asyncio.get_running_loop(), {'pairing_events': pairing_events})
            name = utils.create_observer_name(observer)
            self.bluetooth.adapter_client.register_callback_observer(name, observer)
            observers.append((name, observer))

            streaming_answers_task = asyncio.create_task(streaming_answers(self))

            while True:
                logging.info('OnPairing[%s]: Wait for pairing events...', on_pairing_id)
                address, name, variant, *variables = await pairing_events.get()
                logging.info('OnPairing[%s]: Pairing event: address: %s, name: %s, variant: %s, variables: %s',
                             on_pairing_id, address, name, variant, variables)

                event = security_pb2.PairingEvent()
                event.address = utils.address_to(address)

                # SSP
                if variant == floss_enums.PairingVariant.PASSKEY_CONFIRMATION:
                    [passkey] = variables
                    event.numeric_comparison = passkey
                elif variant == floss_enums.PairingVariant.PASSKEY_ENTRY:
                    event.passkey_entry_request.CopyFrom(empty_pb2.Empty())
                elif variant == floss_enums.PairingVariant.CONSENT:
                    event.just_works.CopyFrom(empty_pb2.Empty())
                elif variant == floss_enums.PairingVariant.PASSKEY_NOTIFICATION:
                    [passkey] = variables
                    event.passkey_entry_notification = passkey
                # Legacy
                elif variant == floss_enums.PairingVariant.PIN_ENTRY:
                    transport = self.bluetooth.get_remote_type(address)

                    if transport == floss_enums.Transport.BREDR:
                        event.pin_code_request.CopyFrom(empty_pb2.Empty())
                    elif transport == floss_enums.Transport.LE:
                        event.passkey_entry_request.CopyFrom(empty_pb2.Empty())
                    else:
                        logging.error('Cannot determine pairing variant from unknown transport.')
                        continue
                elif variant == floss_enums.PairingVariant.PIN_16_DIGITS_ENTRY:
                    event.pin_code_request.CopyFrom(empty_pb2.Empty())
                elif variant == floss_enums.PairingVarint.PIN_NOTIFICATION:
                    transport = self.bluetooth.get_remote_type(address)
                    [pincode] = variables

                    if transport == floss_enums.Transport.BREDR:
                        event.pin_code_notification = pincode.encode()
                    elif transport == floss_enums.Transport.LE:
                        event.passkey_entry_notification = int(pincode)
                    else:
                        logging.error('Cannot determine pairing variant from unknown transport.')
                        continue
                else:
                    logging.error('Unknown pairing variant: %s', variant)
                    continue

                yield event
        finally:
            streaming_answers_task.cancel()
            for name, observer in observers:
                self.bluetooth.adapter_client.unregister_callback_observer(name, observer)

            pairing_events = None
            pairing_answers = None

    async def Secure(self, request: security_pb2.SecureRequest,
                     context: grpc.ServicerContext) -> security_pb2.SecureResponse:
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)  # type: ignore
        context.set_details('Method not implemented!')  # type: ignore
        raise NotImplementedError('Method not implemented!')

    async def WaitSecurity(self, request: security_pb2.WaitSecurityRequest,
                           context: grpc.ServicerContext) -> security_pb2.WaitSecurityResponse:
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)  # type: ignore
        context.set_details('Method not implemented!')  # type: ignore
        raise NotImplementedError('Method not implemented!')


class SecurityStorageService(security_grpc_aio.SecurityStorageServicer):
    """Service to trigger Bluetooth Host security persistent storage procedures.

    This class implements the Pandora bluetooth test interfaces,
    where the meta class definition is automatically generated by the protobuf.
    The interface definition can be found in:
    https://cs.android.com/android/platform/superproject/+/main:external
    /pandora/bt-test-interfaces/pandora/security.proto
    """

    def __init__(self, server: grpc.aio.Server, bluetooth: bluetooth_module.Bluetooth):
        self.server = server
        self.bluetooth = bluetooth

    async def IsBonded(self, request: security_pb2.IsBondedRequest,
                       context: grpc.ServicerContext) -> wrappers_pb2.BoolValue:
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)  # type: ignore
        context.set_details('Method not implemented!')  # type: ignore
        raise NotImplementedError('Method not implemented!')

    async def DeleteBond(self, request: security_pb2.DeleteBondRequest,
                         context: grpc.ServicerContext) -> empty_pb2.Empty:
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)  # type: ignore
        context.set_details('Method not implemented!')  # type: ignore
        raise NotImplementedError('Method not implemented!')
